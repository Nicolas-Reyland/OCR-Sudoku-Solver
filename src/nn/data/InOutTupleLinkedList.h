/* Custom LinkedList Struct */
#include <stdlib.h>
#include <errno.h>
#include <string.h>

// DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
typedef nn_InOutTuple InOutTuple_LINKED_LIST_TYPE;

/* The Node is an element of a LinkedList */
struct InOutTupleNode {
	InOutTuple_LINKED_LIST_TYPE value;
	struct InOutTupleNode *next;
};

/* LinkedList */
typedef struct InOutTupleLinkedLists {
	int num_elements; // dont need this in theory, but saves some calculation time in some functions
	size_t size;
	struct InOutTupleNode *head;
} InOutTupleLinkedList;

/* Check if a given index is valid (for insertion) */
void _InOutTuplecheckIndex(InOutTupleLinkedList *list, int index) {
	if (index > list->num_elements) {
		fprintf(stderr, "Index out of bounds. Exiting\n");
		exit(EXIT_FAILURE);
	}
}

/* Returns the Node at index 'index' of the LinkedList */
struct InOutTupleNode* _InOutTuplegetNodeAtIndex(InOutTupleLinkedList *list, int index) {
	// take the head
	struct InOutTupleNode *element = list->head;
	// go from element to element until the index is reached
	for (int i = 0; i < index; i++) {
		element = element->next;
	}
	// return last element found
	return element;
}
/* Create a new node using malloc, so every node can be freed */
struct InOutTupleNode* _InOutTuplenewNode() {
	// allocate new memory for node
	struct InOutTupleNode *node = (struct InOutTupleNode*) malloc(sizeof(struct InOutTupleNode));
	// if the pointer is NULL, the allocation faled
	if (node == NULL) {
		fprintf(stderr, "Memory allocation for new node failed. Exiting\n");
		exit(EXIT_FAILURE);
	}
	return node;
}

/* intialize a LinkedList (set num_elements, size & head) with a value */
void InOutTupleinitListAtValue(InOutTupleLinkedList *list, InOutTuple_LINKED_LIST_TYPE value) {
	list->num_elements = 1;
	list->size = sizeof(InOutTuple_LINKED_LIST_TYPE);
	list->head = _InOutTuplenewNode(); // so it can be freed ('free(node)') like al the rest
	list->head->value = value;
	list->head->next = NULL;
}

/* Returns the value of the nth element of the LinkedList */
InOutTuple_LINKED_LIST_TYPE InOutTuplegetValueAtIndex(InOutTupleLinkedList *list, int index) {
	// check if index in valid
	_InOutTuplecheckIndex(list, index);
	// get the nth Node of the list
	struct InOutTupleNode *node = _InOutTuplegetNodeAtIndex(list, index);
	// returns its value
	return node->value;
}

/* insert a value at index 'index' in the LinkedList */
void InOutTupleinsertValueAtIndex(InOutTupleLinkedList *list, InOutTuple_LINKED_LIST_TYPE value, int index) {
	// check if the index is valid
	_InOutTuplecheckIndex(list, index);
	// create a new node with value 'value'
	struct InOutTupleNode *current = _InOutTuplenewNode();
	current->value = value;

	// insert at he beginning
	if (index == 0) {
		current->next = list->head;
		// point the head of the list to this node
		list->head = current;
	} else
	// insert at the end of linked list
	if (index == list->num_elements) {
		// get the node before the 'index'
		struct InOutTupleNode *prev = _InOutTuplegetNodeAtIndex(list, index - 1);
		// point the 'prev' node to the 'current' node
		prev->next = current;
		// point the 'current' node to NULL (end of lniked list)
		current->next = NULL;
	} else
	// insert somewhere in the list (except borders)
	{
		// get previous node
		struct InOutTupleNode *prev = _InOutTuplegetNodeAtIndex(list, index - 1);
		// get the node that should come after this node (which is at the current index)
		struct InOutTupleNode *next = _InOutTuplegetNodeAtIndex(list, index);
		// point the current node to the node that was at 'index'
		current->next = next;
		// point the 'prev' node to the 'current' node
		prev->next = current;
	}
	list->num_elements++;
}

/* Removes the Node at index 'index'. Returns it's value */
InOutTuple_LINKED_LIST_TYPE InOutTupleremoveValueAtIndex(InOutTupleLinkedList *list, int index) {
	// check if index is valid (extra line bc first testing with index + 1)
	_InOutTuplecheckIndex(list, index + 1); if (index == -1) {_InOutTuplecheckIndex(list, -1);}
	// declare current node (the one to be removed)
	struct InOutTupleNode *current;

	// remove first element
	if (index == 0) {
		// get head of LinkedList
		current = list->head;
		// change the list head
		list->head = current->next;
	} else
	// remove from anywhere int the list (except start)
	{
		// get the previous node
		struct InOutTupleNode *prev = _InOutTuplegetNodeAtIndex(list, index - 1);
		// get the current node
		current = prev->next;
		// link the previous to the next
		prev->next = current->next;
	}

	// extract value of current (removed node)
	InOutTuple_LINKED_LIST_TYPE value = current->value;
	// free the memory of removed node
	free(current);
	// decrement num_elements
	list->num_elements--;

	return value;
}

void InOutTupleaddValueAtEnd(InOutTupleLinkedList *list, InOutTuple_LINKED_LIST_TYPE value) {
	// get last node of the Linked list
	struct InOutTupleNode *last = _InOutTuplegetNodeAtIndex(list, list->num_elements - 1);
	// create new node with value 'value' and pointing to NULL (end of list)
	struct InOutTupleNode *current = _InOutTuplenewNode();
	current->value = value;
	current->next = NULL;
	// point the previous last node to the new one
	last->next = current;
	// increment
	list->num_elements++;
}

